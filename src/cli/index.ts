import { MongoClient } from "mongodb";
import { mkdir, mkdtemp, readFile, rm, writeFile } from "node:fs/promises";
import os from "node:os";
import path from "node:path";
import { pathToFileURL } from "node:url";
import {
  collectionSchemaVarName,
  collectionToMondelSchemaTs,
  manifestToMondelSchemaTs,
  pullDatabaseSchema,
  syncSchemaIndexes,
  toSafeFileName,
  type PulledCollectionManifest,
  type PulledSchemaManifest,
} from "../kit/index";
import type { Schema } from "../types";
import type { MondelCliConfig, MondelPullFormat } from "./types";

interface CliArgs {
  command?: string;
  flags: Record<string, string | boolean>;
}

interface PullCommandOptions {
  uri: string;
  format: MondelPullFormat;
  outFile?: string;
  outDir?: string;
  perCollectionFiles: boolean;
}

interface PushCommandOptions {
  uri: string;
  schemaFile?: string;
  manifestFile?: string;
  schemaExport: string;
  applyValidators: boolean;
  dropIndexes: boolean;
  dryRun: boolean;
}

function parseArgs(argv: string[]): CliArgs {
  const [command, ...rest] = argv;
  const flags: Record<string, string | boolean> = {};

  for (let i = 0; i < rest.length; i += 1) {
    const token = rest[i];
    if (!token || !token.startsWith("--")) continue;

    const key = token.slice(2);
    const next = rest[i + 1];

    if (!next || next.startsWith("--")) {
      flags[key] = true;
      continue;
    }

    flags[key] = next;
    i += 1;
  }

  return { command, flags };
}

function getStringFlag(flags: Record<string, string | boolean>, name: string): string | undefined {
  const value = flags[name];
  return typeof value === "string" ? value : undefined;
}

function hasFlag(flags: Record<string, string | boolean>, name: string): boolean {
  return flags[name] === true;
}

function showHelp(): void {
  process.stdout.write("Mondel CLI\n\n");
  process.stdout.write("Usage:\n");
  process.stdout.write("  npx mondel pull [options]\n");
  process.stdout.write("  npx mondel push [options]\n\n");
  process.stdout.write("Common options:\n");
  process.stdout.write("  --config <file>         Path to mondel config (.ts/.js/.mjs/.cjs/.json)\n");
  process.stdout.write("  --uri <mongodb-uri>     MongoDB connection string\n");
  process.stdout.write("  (database is inferred from the URI)\n\n");
  process.stdout.write("Pull options:\n");
  process.stdout.write("  --format ts|json        Output format (default: ts)\n");
  process.stdout.write("  --out <file>            Single output file\n");
  process.stdout.write("  --out-dir <dir>         Output directory\n");
  process.stdout.write("  --per-collection        Generate one .ts file per collection (+ index.ts)\n\n");
  process.stdout.write("Push options:\n");
  process.stdout.write("  --schema <file>         Compiled module file exporting schemas\n");
  process.stdout.write("  --manifest <file>       JSON manifest generated by pull\n");
  process.stdout.write("  --export <name>         Export name for schemas array (default: schemas)\n");
  process.stdout.write("  --apply-validators      Apply MongoDB JSON schema validators\n");
  process.stdout.write("  --drop-indexes          Drop remote indexes not present locally\n");
  process.stdout.write("  --dry-run               Print actions without changing the DB\n\n");
  process.stdout.write("Examples:\n");
  process.stdout.write("  npx mondel pull --config ./mondel.config.ts --per-collection\n");
  process.stdout.write("  npx mondel pull --uri mongodb://localhost:27017/app --out ./src/db/schemas.ts\n");
  process.stdout.write("  npx mondel push --uri mongodb://localhost:27017/app --schema ./dist/schemas.js --apply-validators\n");
}

async function importConfigModule(filePath: string): Promise<unknown> {
  const absolutePath = path.resolve(process.cwd(), filePath);
  const extension = path.extname(absolutePath).toLowerCase();

  if (extension === ".json") {
    const raw = await readFile(absolutePath, "utf8");
    return JSON.parse(raw);
  }

  if (extension === ".ts" || extension === ".mts" || extension === ".cts") {
    let typescript: typeof import("typescript");
    try {
      typescript = await import("typescript");
    } catch {
      throw new Error(
        "Loading TypeScript config requires the `typescript` package in your project. Install it or use .js config."
      );
    }

    const source = await readFile(absolutePath, "utf8");
    const compiled = typescript.transpileModule(source, {
      compilerOptions: {
        module: typescript.ModuleKind.ESNext,
        target: typescript.ScriptTarget.ES2020,
      },
      fileName: absolutePath,
    });

    const tempDir = await mkdtemp(path.join(os.tmpdir(), "mondel-config-"));
    const tempFile = path.join(tempDir, `${path.basename(absolutePath, extension)}.mjs`);

    await writeFile(tempFile, compiled.outputText, "utf8");

    try {
      const mod = await import(`${pathToFileURL(tempFile).href}?t=${Date.now()}`);
      return mod;
    } finally {
      await rm(tempDir, { recursive: true, force: true });
    }
  }

  const mod = await import(`${pathToFileURL(absolutePath).href}?t=${Date.now()}`);
  return mod;
}

async function loadCliConfig(configPath?: string): Promise<MondelCliConfig> {
  if (!configPath) return {};

  const mod = await importConfigModule(configPath);
  const maybeConfig =
    typeof mod === "object" && mod !== null && "default" in mod
      ? (mod as { default?: unknown }).default
      : mod;

  if (!maybeConfig || typeof maybeConfig !== "object") {
    throw new Error(`Config in ${configPath} must export an object.`);
  }

  return maybeConfig as MondelCliConfig;
}

async function loadSchemasFromModule(filePath: string, exportName: string): Promise<readonly Schema[]> {
  const absolutePath = path.resolve(process.cwd(), filePath);
  const fileUrl = pathToFileURL(absolutePath).href;
  const mod = await import(`${fileUrl}?t=${Date.now()}`);
  const candidate = mod[exportName];

  if (!Array.isArray(candidate)) {
    throw new Error(`Export "${exportName}" from ${filePath} must be an array of schemas.`);
  }

  return candidate as readonly Schema[];
}

function resolvePullOptions(
  flags: Record<string, string | boolean>,
  config: MondelCliConfig
): PullCommandOptions {
  const uri =
    getStringFlag(flags, "uri") ?? config.pull?.uri ?? config.uri;

  if (!uri) {
    throw new Error("Missing MongoDB URI. Use --uri or provide it in config.");
  }

  const format =
    (getStringFlag(flags, "format") as MondelPullFormat | undefined) ?? config.pull?.format ?? "ts";

  if (format !== "ts" && format !== "json") {
    throw new Error(`Invalid --format "${format}". Use ts or json.`);
  }

  return {
    uri,
    format,
    outFile: getStringFlag(flags, "out") ?? config.pull?.outFile,
    outDir: getStringFlag(flags, "out-dir") ?? config.pull?.outDir,
    perCollectionFiles: hasFlag(flags, "per-collection") || config.pull?.perCollectionFiles === true,
  };
}

function resolvePushOptions(
  flags: Record<string, string | boolean>,
  config: MondelCliConfig
): PushCommandOptions {
  const uri =
    getStringFlag(flags, "uri") ?? config.push?.uri ?? config.uri;

  if (!uri) {
    throw new Error("Missing MongoDB URI. Use --uri or provide it in config.");
  }

  const schemaFile = getStringFlag(flags, "schema") ?? config.push?.schemaFile;
  const manifestFile = getStringFlag(flags, "manifest") ?? config.push?.manifestFile;

  if (!schemaFile && !manifestFile) {
    throw new Error("Provide --schema <module-file> or --manifest <file.json> (or configure push.schemaFile/push.manifestFile).");
  }

  return {
    uri,
    schemaFile,
    manifestFile,
    schemaExport: getStringFlag(flags, "export") ?? config.push?.schemaExport ?? "schemas",
    applyValidators: hasFlag(flags, "apply-validators") || config.push?.applyValidators === true,
    dropIndexes: hasFlag(flags, "drop-indexes") || config.push?.dropIndexes === true,
    dryRun: hasFlag(flags, "dry-run") || config.push?.dryRun === true,
  };
}

function getCollectionIndexFileContent(collections: PulledCollectionManifest[]): string {
  const imports = collections
    .map((collection) => {
      const baseName = `${toSafeFileName(collection.name)}.schema`;
      const varName = collectionSchemaVarName(collection.name);
      return `import { ${varName} } from "./${baseName}";`;
    })
    .join("\n");

  const vars = collections.map((collection) => collectionSchemaVarName(collection.name)).join(", ");

  return [
    "// Generated by mondel pull",
    imports,
    "",
    `export const schemas = [${vars}] as const;`,
    "",
  ].join("\n");
}

async function writePullOutput(
  manifest: PulledSchemaManifest,
  options: PullCommandOptions
): Promise<void> {
  if (options.format === "json") {
    const outFile = options.outFile ?? path.join(options.outDir ?? process.cwd(), "schema-manifest.json");
    await writeFile(path.resolve(process.cwd(), outFile), `${JSON.stringify(manifest, null, 2)}\n`, "utf8");
    process.stdout.write(`Schema manifest written to ${outFile}\n`);
    return;
  }

  if (options.perCollectionFiles || options.outDir) {
    const outDir = path.resolve(process.cwd(), options.outDir ?? "./src/db/schemas");
    await mkdir(outDir, { recursive: true });

    for (const collection of manifest.collections) {
      const fileName = `${toSafeFileName(collection.name)}.schema.ts`;
      const content = collectionToMondelSchemaTs(collection);
      await writeFile(path.join(outDir, fileName), content, "utf8");
    }

    const indexFile = path.join(outDir, "index.ts");
    await writeFile(indexFile, getCollectionIndexFileContent(manifest.collections), "utf8");
    process.stdout.write(`Collection schemas written to ${outDir}\n`);
    process.stdout.write(`Schemas index written to ${indexFile}\n`);
    return;
  }

  const outFile = options.outFile ?? "./mondel.schemas.ts";
  const ts = manifestToMondelSchemaTs(manifest);
  await writeFile(path.resolve(process.cwd(), outFile), ts, "utf8");
  process.stdout.write(`Mondel schema file written to ${outFile}\n`);
}

async function runPull(options: PullCommandOptions): Promise<void> {
  const client = new MongoClient(options.uri);
  await client.connect();

  try {
    const db = client.db();
    const manifest = await pullDatabaseSchema(db);
    await writePullOutput(manifest, options);
  } finally {
    await client.close();
  }
}

async function runPush(options: PushCommandOptions): Promise<void> {
  let schemas: readonly Schema[];

  if (options.manifestFile) {
    const raw = await readFile(path.resolve(process.cwd(), options.manifestFile), "utf8");
    const manifest = JSON.parse(raw) as PulledSchemaManifest;
    schemas = manifest.collections.map((collection) => ({
      name: collection.name,
      collection: collection.name,
      fields: collection.fields,
      indexes: collection.indexes,
      timestamps: false,
      validation: { enabled: true, mode: "strict" },
    }));
  } else {
    schemas = await loadSchemasFromModule(options.schemaFile as string, options.schemaExport);
  }

  const client = new MongoClient(options.uri);
  await client.connect();

  try {
    const db = client.db();
    await syncSchemaIndexes(db, schemas, {
      applyValidators: options.applyValidators,
      dropUndefinedIndexes: options.dropIndexes,
      dryRun: options.dryRun,
      logger: (message: string) => process.stdout.write(`${message}\n`),
    });

    process.stdout.write("Push finished successfully.\n");
  } finally {
    await client.close();
  }
}

async function main(): Promise<void> {
  const { command, flags } = parseArgs(process.argv.slice(2));

  if (!command || command === "help" || hasFlag(flags, "help")) {
    showHelp();
    return;
  }

  const configPath = getStringFlag(flags, "config") ?? "./mondel.config.ts";
  const config = await loadCliConfig(configPath).catch(async (error: unknown) => {
    if (getStringFlag(flags, "config")) {
      const reason = error instanceof Error ? error.message : String(error);
      throw new Error(`Unable to load config at ${configPath}: ${reason}`);
    }

    return {} as MondelCliConfig;
  });

  if (command === "pull") {
    const options = resolvePullOptions(flags, config);
    await runPull(options);
    return;
  }

  if (command === "push") {
    const options = resolvePushOptions(flags, config);
    await runPush(options);
    return;
  }

  throw new Error(`Unknown command "${command}". Use "npx mondel help".`);
}

main().catch((error) => {
  const message = error instanceof Error ? error.message : String(error);
  process.stderr.write(`mondel: ${message}\n`);
  process.exitCode = 1;
});
